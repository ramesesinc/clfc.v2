
import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;
import com.rameses.osiris3.core.AppContext;
import com.rameses.osiris3.core.OsirisServer;
import com.rameses.osiris3.script.*;
import com.rameses.osiris3.xconnection.XConnection;
import java.rmi.server.UID;
import java.io.PrintWriter;
import java.io.StringWriter;

class AsyncNotificationNotifyTask 
{	
    @ActiveDB(value='async_notification', em='notification')
    def em;

    @Service(value='AsyncNotificationService', connection='script_proxy') 
    def service;

	@Service('DateService')
	def dateSvc;    

	@Service 
	def self; 

	@Env 
	def sysEnv; 

	//@Schedule(interval=2)
	public void fetchPendingData( task ) {
		def rundate = dateSvc.serverDate;
		if (!task.properties.loaded) { 
			//server has just started, remove all processes 
			println 'removing previous async notification processes...'			
			em.removeProcessBefore([dtfiled: rundate]); 
			task.properties.loaded = true; 

		} else {
			def list = em.getPendingList([_start:0, _limit:20]); 
			while (!list.isEmpty()) {
				def data = list.remove(0); 
				data.rundate = rundate; 
				processPendingData( data ); 
			}
		}
	} 

	private void processPendingData( data ) {
		try { 
			def rundate = data.rundate; 
			if (data.dtretry && data.dtretry.before(rundate)) { 
				def procdata = [objid:data.objid, dtfiled:rundate];
				em.create( procdata, 'processing' ); 
				self.publishMessage( data ); 
			} else { 
				//rerun on next schedule 
			} 
		} catch(Throwable t) { 
			println '[AsyncNotificationNotifyTask] failed to process pending message caused by ' + t.class.name + ': ' + t.message; 
		} 
	} 

	@Context 
	def currentContext;

	@Async
	@ProxyMethod(local=true) 
	public void publishMessage( params ) {
		def msgObj = em.read([objid: params.objid]); 
		if (!msgObj) return; 

		def asyncReq = new Base64Cipher().decode(msgObj.data); 
		if (!asyncReq.contextName) asyncReq.contextName='default'; 

		def envmap = (sysEnv? sysEnv: [:]);
		envmap.requester = (asyncReq.env? asyncReq.env: [:]); 

		def appCtx = OsirisServer.instance.getContext(AppContext.class, asyncReq.contextName);
		def scriptObj = new ScriptRunnable(appCtx); 
		scriptObj.serviceName = asyncReq.serviceName; 
		scriptObj.methodName  = asyncReq.methodName; 
		scriptObj.args = asyncReq.args; 
		scriptObj.env  = envmap;
		scriptObj.listener = [ 
			onBegin: {},
			onClose: {}, 
			onCancel: {}, 
			onRollback: {exception-> 
				processError(exception, params.objid) 
			}, 
			onComplete: {o-> 
				processResult(appCtx, asyncReq, params.objid, o) 
			} 
		] as ScriptRunnable.Listener; 
		appCtx.submitAsync(scriptObj); 
	}

	private void processError(exception, msgid) {
		try {
			println 'processError: ' + msgid;
			service.reschedulePending([objid: msgid]); 
			def info = service.findPending([objid: msgid]); 
			if (info?.retrycount > 3) {
				if (!exception) exception=new Exception('Message already expired');

				def buffer = new StringWriter();
				exception.printStackTrace(new PrintWriter(buffer)); 
				service.markAsFailed([ 
					objid 		 : msgid, 
					errormessage : buffer.toString()  
				]); 
			}
		} catch(e) { 
			e.printStackTrace(); 
		} 
	} 

	private void processResult(appCtx, asyncReq, msgid, result) { 
		if (!result) return; 

		def connName = asyncReq.connection; 
		if (!connName) return; 

		def xconn = appCtx.getResource( XConnection.class, connName ); 
		if (!xconn) { 
			println "[AsyncNotificationNotifyTask] '"+ connName + "' connection not found"; 
			return; 
		} 

		def queue = xconn.register( asyncReq.id ); 
		queue.push( result ); 
		queue.push( new AsyncToken(closed:true) ); 
		service.markAsDelivered([objid: msgid]); 
	} 
} 
