import com.rameses.annotations.*;
import com.rameses.common.*
import com.rameses.services.extended.*
import com.rameses.util.*;

class AFInventoryToolInterceptor { 

	@ActiveDB('afinventory_tool') 
	def em; 

	@ActiveDB('af_inventory') 
	def afi_em; 

	@ActiveDB('af_control') 
	def afc_em; 

	@Env 
	def env; 


	@After( pattern="AFInventoryService.fixInventory" )
	public void onFixAF ( evt ) { 
		def params = evt.args[0]; 
		process( params ); 
	} 

	@After( pattern="UnremittedCollectionService.fixInventory" )
	public void onFixUnremittedAF ( evt ) { 
		def params = evt.args[0]; 
		def collectorid = (params.collectorid? params.collectorid : env.USERID); 
		params.collectorid = collectorid;  

		def list = em.getUnremittedAFs( params );
		if ( !list ) throw new Exception('No available unremitted AF'); 

		list.each{ process( it ) }  
	} 

	void process( params ) {
		def afidata = afi_em.read( params ); 
		if ( !afidata ) throw new Exception(''+ params.objid + ' AF inventory record not found'); 

		if ( !afidata.respcenter?.type.toString().equalsIgnoreCase('COLLECTOR') ) 
			throw new Exception('This facility is only applicable to COLLECTOR respcenter type');

		if ( afidata.qtyin > 0 ) { 
			def receipts = em.getReceipts([ controlid : params.objid ]);
			if ( !receipts ) return;

			def formtype = receipts[0].formtype;
			def afi_currentseries = afidata.currentseries;
			def afc_currentseries = afidata.currentseries; 

			if ( formtype == 'serial' ) {
				def minseries = receipts.min{ it.series }.series; 
				afc_currentseries = minseries + receipts.size(); 
				afi_currentseries = minseries + receipts.findAll{( it.remitted > 0 )}.size(); 

			} else if ( formtype == 'cashticket' ) { 
				def denomination = receipts[0].denomination;
				def nextseries = receipts.findAll{( it.voided==0 )}.min{ it.series }.series; 
				receipts.each{ 
					if ( it.voided == 0 ) {
						it.currentseries = nextseries; 
						it.nextseries = it.currentseries + (it.amount / denomination);  
						nextseries = it.nextseries; 
					} else { 
						it.currentseries = nextseries; 
						it.nextseries = it.currentseries; 
					} 

					em.updateReceiptSeries([ 
						objid: it.receiptid, 
						series: it.series, 
						currentseries: it.currentseries 
					]);  
				} 

				receipts = receipts.findAll{ it.voided==0 }
				afc_currentseries = receipts.max{ it.nextseries }.nextseries;  

				def maxrem = receipts.findAll{( it.remitted > 0 )}.max{ it.nextseries } 
				afi_currentseries = (maxrem? maxrem.nextseries: afc_currentseries); 
			} 

			//update af_control 
			def afcdata = afc_em.read( afidata );
			afcdata.currentseries = afc_currentseries; 
			if ( afcdata.currentseries > afcdata.endseries ) {
				afcdata.currentseries = afcdata.endseries+1; 
			} 
			afc_em.update( afcdata ); 

			//update af_inventory  
			afidata.currentseries = afi_currentseries; 
			if ( afidata.currentseries > afidata.endseries ) {
				afidata.currentseries = afidata.endseries+1; 
				afidata.qtyout = afidata.qtyin; 
			} else {
				afidata.qtyout = afidata.currentseries - afidata.startseries; 
			}
			afidata.qtybalance = afidata.qtyin - afidata.qtyout; 
			afi_em.update( afidata );  
		} 
	}
}